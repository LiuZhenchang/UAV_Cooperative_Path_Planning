%****************************************************************************************************************************
% Discription:  Generate cooperative Dubins paths based on the starting and ending information of each UAV
% input:        StartInfo               Starting point information
% input:        FinishInfo              Ending point information
% input:        Property                Structure of path planning parameters
% output:       Waypoint_Series         Matrix of waypoint sqruences of all UAVs
%****************************************************************************************************************************

function Waypoint_Series = Dubins_Path_Planning(StartInfo,FinishInfo,Property)

ns=Property.ns;                                                     % Number of discrete points in the starting arc
nl=Property.nl;                                                     % Number of discrete points in the straight line
nf=Property.nf;                                                     % Number of discrete points in the ending arc

%% Generate a Dubins paths information table sort by UAV numbers       
[uav_num,~]=size(StartInfo);
Dubins_Table_UAV=zeros(uav_num*4,3);                                % Initialize the Dubins path information table (sorted by UAV number)
Dubins_Table_Traj=zeros(uav_num*4,3);                               % Initialize the Dubins path information table (sorted by path length)
index=1;                                                            % Initialize the row index of the table
for i=1:uav_num
    for type=1:4
        dubins_info=...
            Dubins_Init(StartInfo(i,:),FinishInfo(i,:));            % Initialize basic Dubins path structure based on starting and ending information
        dubins_info=Dubins_Generate(dubins_info,type);              % Generate complete path information based on basic path information and path type
        Dubins_Table_UAV(index,1)=i;                                % Store the UAV number in column 1 of the table
        Dubins_Table_UAV(index,2)=type;                             % Store the path type in column 2 of the table
        Dubins_Table_UAV(index,3)=dubins_info.traj.length;          % Store the path length in column 2 of the table
        index=index+1;
    end
end

%% Generate a Dubins paths information table sort by path length     
L_traj_1=Dubins_Table_UAV(:,3);                                     % Extract the length of each path to form an array
L_traj_2=sort(L_traj_1);                                            % Arrange the elements in the L_traj_1 from small to large to generate a new array
for i=1:4*uav_num
    for j=1:4*uav_num
        if L_traj_2(i)==L_traj_1(j)                                 % Find elements in two arrays with the same path length
            if i==1
                Dubins_Table_Traj(i,:)=Dubins_Table_UAV(j,:);       % Re store the Dubins path information in ascending order of path length
                break;
            
            % When encountering situations where the trajectory length is the same, 
            % determine whether the drone number and trajectory type are the same, 
            % and store non duplicate information in the Dubins trajectory information table
            elseif Dubins_Table_Traj(i-1,1)~=Dubins_Table_UAV(j,1)||...
                    Dubins_Table_Traj(i-1,2)~=Dubins_Table_UAV(j,2)
                    Dubins_Table_Traj(i,:)=Dubins_Table_UAV(j,:);
                    break;
            end
        end
    end
end

%% Determine whether each path has the possibility of collaboration
Coor_Table_Traj=zeros(uav_num*4,uav_num);                           % Initialize the cooperative detection table to record whether each UAV can 
                                                                    % plan a path that meets the current path length
                                                                    % The rows in the table represent path numbers, and the columns represent UAV numbers
for i=uav_num:4*uav_num                                             % Traverse all dubins paths
    count=0;                                                        % The counter is used to count how many UAVs meet the path requirements
    for j=1:uav_num                                                 % Traverse all UAVs
        if Dubins_Table_Traj(i,1)==j                                % If the path is generated by the current UAV, there is no need to detect it
            Coor_Table_Traj(i,j)=1;                                 % Marke the UAV can plan a path that meets the current path length
        else
            length=Dubins_Table_Traj(i,3);                          % Obtain the current path length
            dubins_info=...
            Dubins_Init(StartInfo(j,:),FinishInfo(j,:));            % Initialize basic Dubins path structure based on starting and ending information
            [Coor_Table_Traj(i,j),~]=...                            % Determine whether UAV cab plan a path that meets the current path length
                Dubins_Length_Check(length,dubins_info);            % If possible, mark it as 1 in the table, not 0
        end
        count=count+Coor_Table_Traj(i,j);                           % Count how many UAVs meet the required flight path length
    end
    if count==uav_num                                               % If all UAVs meet the requirements
        index=i;                                                    % Record the current path number
        break;                                                      % Stop the loop, and subsequent paths will no longer be checked
    end
end

%% Generate discret waypoints basd on dubins path
length=Dubins_Table_Traj(index,3);                                  % Obtain the cooperative path length
point_num=ns+nl+nf+3;
Waypoint_Series=zeros(uav_num*2,point_num);                         % Initialize matrix of waypoint sqruences of all UAVs
dubins_group=repmat(dubins_info,uav_num,1);                         % Initialize the storage array of the dubins structure for each UAV
for j=1:uav_num
    dubins_info=...
    Dubins_Init(StartInfo(j,:),FinishInfo(j,:));                    % Initialize basic Dubins path structure based on starting and ending information
    [~,dubins_info]=...                                             % Detect whether each UAV can generate paths that meet the length requirements
        Dubins_Length_Check(length,dubins_info);                    % Obtain generated path information
    dubins_group(j)=dubins_info;                                    % Store generated path information
    [dubins_x,dubins_y]=Dubins_Discret(dubins_info,ns,nl,nf);       % Generate discrete waypoints
    [~,c]=size(dubins_x);                                           % Obtain waypoints number    
    Waypoint_Series(j*2-1,1:c)=dubins_x;                            % Store waypoints in the the matrix according to UAV numbers
    Waypoint_Series(j*2,1:c)=dubins_y;
    
%     plot(dubins_x,dubins_y);
%     hold on;
end

